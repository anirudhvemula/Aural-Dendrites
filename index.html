<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Tesla Coil Plasma Discharge Audio Visualizer</title>
	<!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./favicon.png">

    <!-- Open Graph / Social Preview -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Aniâ€™s Tesla Coil Sonic Visualizer">
    <meta property="og:description" content="Aural-Dendrites is a generative system exploring how dendritic structures emerge from electric and sonic fields. Inspired by electrical discharges, neural growth, and plasma phenomena, the project treats sound and electricity not as signals, but as forces that shape form, motion, and decay over time.">
    <meta property="og:url" content="https://anirudhvemula.github.io/Aural-Dendrites/">
    <meta property="og:image" content="https://anirudhvemula.github.io/Aural-Dendrites/og-preview.png">
    <meta property="og:image:width" content="840">
    <meta property="og:image:height" content="750">

    <!-- Twitter / X -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Aniâ€™s Tesla Coil Sonic Visualizer">
    <meta name="twitter:description" content="Aural-Dendrites displays Tesla Coil Electric Discharges which are Audio Reactive (WebGL 2.0)">
    <meta name="twitter:image" content="https://anirudhvemula.github.io/Aural-Dendrites/og-preview.png">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background:#000; overflow:hidden;
    height:100vh; width:100vw;
    font-family:'Share Tech Mono',monospace;
    color:#fff; user-select:none;
  }
  canvas#glCanvas { display:block; position:absolute; inset:0; width:100%; height:100%; }

  #ui {
    position:fixed; inset:0; z-index:10;
    pointer-events:none;
    display:flex; flex-direction:column;
    justify-content:space-between;
    padding:28px 32px;
  }
  #header { display:flex; justify-content:space-between; align-items:flex-start; }
  #title-block h1 {
    font-family:'Orbitron',sans-serif;
    font-size:1.15rem; font-weight:700;
    letter-spacing:0.18em; text-transform:uppercase;
    color:#c8b8ff; text-shadow:0 0 12px rgba(180,140,255,0.6);
  }
  #title-block p { font-size:0.7rem; color:rgba(200,180,255,0.45); margin-top:3px; letter-spacing:0.1em; }
  #freq-display { text-align:right; font-size:0.65rem; color:rgba(200,180,255,0.4); letter-spacing:0.08em; line-height:1.7; }
  #freq-display span { color:rgba(220,200,255,0.75); }

  #controls {
    pointer-events:auto;
    display:flex; align-items:center; gap:18px;
    background:rgba(12,8,24,0.72);
    backdrop-filter:blur(14px);
    border:1px solid rgba(180,140,255,0.18);
    border-radius:14px; padding:14px 20px;
    width:fit-content; margin:0 auto;
  }
  .ctrl-btn {
    background:rgba(180,140,255,0.12);
    border:1px solid rgba(180,140,255,0.3);
    border-radius:10px; color:#c8b8ff;
    font-family:'Share Tech Mono',monospace;
    font-size:0.72rem; letter-spacing:0.1em;
    padding:9px 16px; cursor:pointer;
    transition:background 0.2s, box-shadow 0.2s;
  }
  .ctrl-btn:hover { background:rgba(180,140,255,0.25); box-shadow:0 0 10px rgba(180,140,255,0.3); }
  .ctrl-btn.active { background:rgba(180,140,255,0.3); box-shadow:0 0 12px rgba(180,140,255,0.45); }
  #file-input { display:none; }
  #track-name { font-size:0.68rem; color:rgba(200,180,255,0.55); letter-spacing:0.06em; max-width:180px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  #intensity-ring {
    width:34px; height:34px; border-radius:50%;
    border:2px solid rgba(180,140,255,0.25);
    display:flex; align-items:center; justify-content:center;
    position:relative;
  }
  #intensity-ring::after {
    content:''; position:absolute; inset:3px; border-radius:50%;
    background:radial-gradient(circle, rgba(180,140,255,0.6), transparent 70%);
    transform:scale(var(--intensity, 0)); transition:transform 0.1s;
  }
  #waveCanvas { width:140px; height:34px; border-radius:8px; background:rgba(180,140,255,0.06); border:1px solid rgba(180,140,255,0.15); }
</style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<div id="ui">
  <div id="header">
    <div id="title-block">
      <h1>âš¡ Aural-Dendrites âš¡</h1>
          <p>Tesla Coil Plasma Discharge Audio Visualizer</p>
          <p>By Anirudh Vemula, PE (2026)</p>
    </div>
    <div id="freq-display">
      Bass: <span id="bass">0</span> &nbsp; Mid: <span id="mid">0</span> &nbsp; Hi: <span id="hi">0</span><br/>
      FPS: <span id="fps">60</span>
    </div>
  </div>
  <div id="controls">
    <input type="file" id="file-input" accept="audio/*" />
    <button class="ctrl-btn" id="btn-load">ğŸ“‚ Load Audio</button>
    <button class="ctrl-btn" id="btn-play" disabled>â–¶ Play</button>
    <div id="intensity-ring"></div>
    <canvas id="waveCanvas" width="280" height="68"></canvas>
    <span id="track-name">No track loaded</span>
  </div>
</div>

<script>
// ============================================================
// AUDIO ENGINE
// ============================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx, analyser, source, audioBuffer;
let isPlaying = false, startedAt = 0, pausedAt = 0;
const FFT_SIZE = 2048;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new AudioCtx();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = FFT_SIZE;
  analyser.smoothingTimeConstant = 0.78;
  analyser.connect(audioCtx.destination);
}
async function loadAudioFile(file) {
  initAudio();
  audioBuffer = await audioCtx.decodeAudioData(await file.arrayBuffer());
  document.getElementById('track-name').textContent = file.name.replace(/\.[^.]+$/, '');
  document.getElementById('btn-play').disabled = false;
  stopAudio();
}
function playAudio() {
  if (!audioBuffer) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(analyser);
  source.start(0, pausedAt);
  startedAt = audioCtx.currentTime - pausedAt;
  isPlaying = true;
  source.onended = () => { if (isPlaying) stopAudio(); };
  document.getElementById('btn-play').textContent = 'â¸ Pause';
  document.getElementById('btn-play').classList.add('active');
}
function pauseAudio() {
  if (!source) return;
  pausedAt = audioCtx.currentTime - startedAt;
  source.stop(); isPlaying = false;
  document.getElementById('btn-play').textContent = 'â–¶ Play';
  document.getElementById('btn-play').classList.remove('active');
}
function stopAudio() {
  if (source) { try { source.stop(); } catch(e){} }
  isPlaying = false; pausedAt = 0;
  document.getElementById('btn-play').textContent = 'â–¶ Play';
  document.getElementById('btn-play').classList.remove('active');
}

document.getElementById('btn-load').addEventListener('click', () => document.getElementById('file-input').click());
document.getElementById('file-input').addEventListener('change', e => { if (e.target.files[0]) loadAudioFile(e.target.files[0]); });
document.getElementById('btn-play').addEventListener('click', () => { isPlaying ? pauseAudio() : playAudio(); });

// ============================================================
// WEBGL 2.0
// ============================================================
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');
if (!gl) { document.body.innerHTML = '<h2 style="color:#f66;padding:40px">WebGL 2.0 not supported.</h2>'; }

function resize() {
  canvas.width  = window.innerWidth  * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

function compileShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); return null; }
  return s;
}
function linkProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(p)); return null; }
  return p;
}

// ============================================================
// SHADERS
// ============================================================
const VERT_SRC = `#version 300 es
layout(location=0) in vec2 a_pos;
out vec2 v_uv;
void main() { v_uv = a_pos*0.5+0.5; gl_Position = vec4(a_pos,0.0,1.0); }`;

const FRAG_SRC = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 out_color;

uniform float u_time;
uniform float u_bass;
uniform float u_mid;
uniform float u_hi;
uniform float u_energy;
uniform float u_burst;
uniform vec2  u_resolution;

// â”€â”€â”€ hash â”€â”€â”€
float hash1(float n) { return fract(sin(n)*43758.5453); }

// â”€â”€â”€ nucleus â”€â”€â”€
vec2 NUCLEUS = vec2(0.0, -0.20);

// â”€â”€â”€ per-ray length personality â”€â”€â”€
float rayPersonality(float idx) { return 0.6 + hash1(idx*7.13+1.0)*0.8; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RECURSIVE BRANCH TRACER with sharp zigzag lightning jitter
// Returns minimum distance to any segment of the entire branch tree
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trace a single unbranched ray segment-by-segment with sharp zigzag
// Returns: vec3(minDist, endX, endY) so branches can spawn from endpoints
vec3 traceBolt(vec2 p, vec2 startPos, float baseAngle, float timeSeed, float totalLen, int maxSeg) {
  vec2  pos  = startPos;
  float minD = 1e6;
  float segL = totalLen / float(maxSeg);

  for (int i = 0; i < 24; i++) {
    if (i >= maxSeg) break;
    float fi    = float(i);
    float jSeed = timeSeed + fi*7.31;
    float jTime = floor(u_time*9.0 + timeSeed*0.8);
    
    // SHARP ZIGZAG: quantize jitter to discrete left/right snaps
    float jRaw  = hash1(jSeed+jTime);
    float jDir  = sign(jRaw - 0.5); // -1 or +1
    float jMag  = 0.65 + hash1(jSeed+jTime+100.0)*0.35; // 0.65..1.0
    float j     = jDir * jMag * (0.45 + u_bass*0.55);
    
    // Additional high-freq micro-jitter for texture
    float microJ = (hash1(jSeed+jTime+200.0)-0.5)*0.15;
    j += microJ;

    vec2 next = pos + vec2(cos(baseAngle+j), sin(baseAngle+j)) * segL;
    vec2 ab   = next - pos;
    float l2  = dot(ab,ab);
    float tt  = l2 > 0.0 ? clamp(dot(p-pos,ab)/l2, 0.0, 1.0) : 0.0;
    float d   = length(p - (pos + ab*tt));
    minD = min(minD, d);
    pos = next;
  }
  return vec3(minD, pos.x, pos.y);
}

// Full recursive branch system (unrolled 3 levels deep)
// Returns vec3(dist_level0, dist_level1, dist_level2) - min distance to each branch level
vec3 traceRecursiveBranches(vec2 p, vec2 origin, float baseAngle, float timeSeed, float mainLen, float personality) {
  float dist0 = 1e6; // trunk
  float dist1 = 1e6; // secondary branches
  float dist2 = 1e6; // tertiary branches

  // â”€â”€â”€ LEVEL 0: Main trunk â”€â”€â”€
  vec3 trunk = traceBolt(p, origin, baseAngle, timeSeed, mainLen, 22);
  dist0 = trunk.x;

  // â”€â”€â”€ LEVEL 1: Secondary branches (spawn at 3 points along trunk) â”€â”€â”€
  for (int b1 = 0; b1 < 3; b1++) {
    float fb1 = float(b1);
    
    float spawnT = 0.25 + fb1*0.25;
    vec2 spawnPos = origin + vec2(cos(baseAngle), sin(baseAngle)) * (mainLen * spawnT);
    
    float b1Seed = timeSeed + fb1*31.7 + 100.0;
    float b1Dev  = (hash1(b1Seed)-0.5) * 1.57;
    float b1Ang  = baseAngle + b1Dev;
    float b1Len  = mainLen * (0.35 + hash1(b1Seed+50.0)*0.15) * personality;
    
    float b1Spawn = step(fb1*0.15, u_energy);
    if (b1Spawn < 0.5) continue;
    
    vec3 branch1 = traceBolt(p, spawnPos, b1Ang, b1Seed, b1Len, 14);
    dist1 = min(dist1, branch1.x);

    // â”€â”€â”€ LEVEL 2: Tertiary branches â”€â”€â”€
    for (int b2 = 0; b2 < 2; b2++) {
      float fb2 = float(b2);
      
      float b2SpawnT = 0.5 + fb2*0.25;
      vec2 b2SpawnPos = spawnPos + vec2(cos(b1Ang), sin(b1Ang)) * (b1Len * b2SpawnT);
      
      float b2Seed = b1Seed + fb2*17.3 + 200.0;
      float b2Dev  = (hash1(b2Seed)-0.5) * 1.3;
      float b2Ang  = b1Ang + b2Dev;
      float b2Len  = b1Len * (0.20 + hash1(b2Seed+60.0)*0.10);
      
      float b2Spawn = step(0.3 + fb2*0.2, u_energy);
      if (b2Spawn < 0.5) continue;
      
      vec3 branch2 = traceBolt(p, b2SpawnPos, b2Ang, b2Seed, b2Len, 8);
      dist2 = min(dist2, branch2.x);
    }
  }

  return vec3(dist0, dist1, dist2);
}

// â”€â”€â”€ Corona arc (unchanged, for 360Â° ring) â”€â”€â”€
float traceCorona(vec2 p, float angle, float timeSeed, float len) {
  vec2  pos  = NUCLEUS;
  float minD = 1e6;
  float segL = len / 8.0;
  for (int i = 0; i < 8; i++) {
    float fi    = float(i);
    float jTime = floor(u_time*14.0 + timeSeed);
    float jRaw  = hash1(timeSeed + fi*5.7 + jTime);
    float j     = sign(jRaw-0.5) * 0.45; // sharp zigzag for corona too
    vec2  next  = pos + vec2(cos(angle+j*0.6), sin(angle+j*0.6))*segL;
    vec2  ab    = next-pos;
    float l2    = dot(ab,ab);
    float tt    = l2>0.0 ? clamp(dot(p-pos,ab)/l2,0.0,1.0) : 0.0;
    minD = min(minD, length(p-(pos+ab*tt)));
    pos = next;
  }
  return minD;
}

void main() {
  vec2  uv     = v_uv - 0.5;
  float aspect = u_resolution.x / u_resolution.y;
  uv.x *= aspect;
  float nr = length(uv - NUCLEUS);
  vec3  col = vec3(0.0);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• NUCLEUS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  float coreSize = 0.020 + u_bass*0.016 + u_burst*0.012;
  float core     = exp(-nr*nr / (coreSize*coreSize*0.5));
  core *= 0.82 + 0.18*sin(u_time*24.0 + u_bass*45.0);
  col += vec3(0.97,0.93,1.0) * core * 3.0;
  col += vec3(0.50,0.32,0.80) * exp(-nr*nr/(0.0010+u_bass*0.0007+u_burst*0.0006)) * 1.1;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LAYER A: PERSISTENT BRANCHING RAYS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  float persistCount = 5.0 + u_energy*5.0;   // 5 idle â†’ 10 active

  for (int ray = 0; ray < 10; ray++) {
    float fr = float(ray);
    if (fr >= persistCount) break;

    float personality = rayPersonality(fr);
    float angleSeed   = hash1(fr*3.7+0.5);
    float baseAngle   = mix(0.60, 2.54, angleSeed);
    float tSeed       = fr*17.3 + floor(u_time*7.0 + fr*2.1);

    // Length: idle small, audio stretches dramatically
    float rayLen = (0.10 + 0.38*(u_energy*0.6 + u_bass*0.3 + u_burst*0.25)) * personality;

    // Flicker
    float alive     = step(0.0, sin(u_time*(5.0+u_energy*8.0) + fr*5.7));
    float burstBoost = u_burst * 1.5;

    // Trace entire recursive branch tree
    vec3 distances = traceRecursiveBranches(uv, NUCLEUS, baseAngle, tSeed, rayLen, personality);

    // Apply thickness per level: trunk (1.0x), secondary (0.55x), tertiary (0.32x)
    float baseThick = 0.0026 + u_bass*0.0010 + u_burst*0.0008;
    
    float thick0 = baseThick * 1.0;   // trunk
    float thick1 = baseThick * 0.55;  // secondary
    float thick2 = baseThick * 0.32;  // tertiary
    
    float bright0 = exp(-distances.x*distances.x / (thick0*thick0));
    float bright1 = exp(-distances.y*distances.y / (thick1*thick1));
    float bright2 = exp(-distances.z*distances.z / (thick2*thick2));
    
    float totalBright = bright0 + bright1 + bright2;

    // Color based on closest distance (approximation)
    float minDist = min(distances.x, min(distances.y, distances.z));
    float colorT = clamp(minDist*25.0, 0.0, 1.0);
    vec3 rayCol = mix(vec3(0.92,0.88,1.0), vec3(0.82,0.42,0.95), colorT);
    
    col += rayCol * min(totalBright*(alive+burstBoost), 3.5) * 2.6;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LAYER B: BURST RAYS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  float burstCount = floor(u_burst*7.0 + 0.5);

  for (int ray = 0; ray < 7; ray++) {
    float fr = float(ray);
    if (fr >= burstCount) break;

    float personality = rayPersonality(fr+100.0);
    float angleSeed   = hash1(fr*5.1+77.0);
    float baseAngle   = mix(0.45, 2.70, angleSeed);
    float tSeed       = fr*31.7 + floor(u_time*3.5+fr*4.2)*13.0 + 500.0;
    float rayLen      = (0.28 + u_bass*0.22 + 0.14) * personality;

    vec3 distances = traceRecursiveBranches(uv, NUCLEUS, baseAngle, tSeed, rayLen, personality);

    float baseThick = 0.0030 + u_burst*0.0012;
    
    float thick0 = baseThick * 1.0;
    float thick1 = baseThick * 0.55;
    float thick2 = baseThick * 0.32;
    
    float bright0 = exp(-distances.x*distances.x / (thick0*thick0));
    float bright1 = exp(-distances.y*distances.y / (thick1*thick1));
    float bright2 = exp(-distances.z*distances.z / (thick2*thick2));
    
    float totalBright = bright0 + bright1 + bright2;

    float minDist = min(distances.x, min(distances.y, distances.z));
    float colorT = clamp(minDist*20.0, 0.0, 1.0);
    vec3 rayCol = mix(vec3(1.0,0.96,1.0), vec3(0.75,0.35,0.90), colorT);
    col += rayCol * totalBright * u_burst * 3.4;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LAYER C: 360Â° CORONA RING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  float coronaCount = 6.0 + u_energy*8.0;

  for (int c = 0; c < 14; c++) {
    float fc = float(c);
    if (fc >= coronaCount) break;

    float baseA  = (fc/14.0)*6.2832;
    float wobble = sin(u_time*4.0+fc*2.1)*0.12*(0.4+u_energy*0.6);
    float angle  = baseA + wobble;
    float cLen   = 0.055 + u_mid*0.045 + u_burst*0.03;
    float tSeed  = fc*9.1 + floor(u_time*12.0+fc*1.7);
    float cAlive = max(step(0.0, sin(u_time*(10.0+fc*1.1)+fc*4.3)), u_energy*0.3);

    float cd = traceCorona(uv, angle, tSeed, cLen);
    vec3  cCol = mix(vec3(0.40,0.25,0.80), vec3(0.70,0.55,1.0), u_energy);
    col += cCol * exp(-cd*cd/(0.00085*0.00085)) * cAlive * 1.1;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ATMOSPHERE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  col += vec3(0.28,0.14,0.52) * exp(-nr*nr/(0.0035+u_bass*0.0025+u_burst*0.0018)) * (0.25+u_bass*0.35+u_burst*0.3);
  col += vec3(0.22,0.12,0.40) * exp(-abs(uv.y-NUCLEUS.y)*abs(uv.y-NUCLEUS.y)/0.0006) * 0.10;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TONE MAP + VIGNETTE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  col  = col / (1.0 + col*0.55);
  float vr = length(v_uv-0.5)*1.55;
  col *= 1.0 - clamp(vr*vr*0.38, 0.0, 0.62);

  out_color = vec4(col, 1.0);
}`;

// ============================================================
// COMPILE & SETUP
// ============================================================
const vs   = compileShader(VERT_SRC, gl.VERTEX_SHADER);
const fs   = compileShader(FRAG_SRC, gl.FRAGMENT_SHADER);
const prog = linkProgram(vs, fs);
gl.useProgram(prog);

const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

const uTime       = gl.getUniformLocation(prog, 'u_time');
const uBass       = gl.getUniformLocation(prog, 'u_bass');
const uMid        = gl.getUniformLocation(prog, 'u_mid');
const uHi         = gl.getUniformLocation(prog, 'u_hi');
const uEnergy     = gl.getUniformLocation(prog, 'u_energy');
const uBurst      = gl.getUniformLocation(prog, 'u_burst');
const uResolution = gl.getUniformLocation(prog, 'u_resolution');
gl.uniform2f(uResolution, canvas.width, canvas.height);

// ============================================================
// AUDIO ANALYSIS + TRANSIENT DETECTOR + RENDER
// ============================================================
const freqData = new Uint8Array(FFT_SIZE / 2);
const waveData = new Uint8Array(FFT_SIZE);
const waveCanvas = document.getElementById('waveCanvas');
const wCtx       = waveCanvas.getContext('2d');

let sBass=0, sMid=0, sHi=0, sEnergy=0;
let prevBass=0, burstVal=0;
let lastTime = performance.now(), fps=60;

function getAudioData() {
  if (!analyser) return;
  analyser.getByteFrequencyData(freqData);
  analyser.getByteTimeDomainData(waveData);

  const bassEnd = Math.floor(freqData.length*0.08);
  const midEnd  = Math.floor(freqData.length*0.35);
  let bSum=0, mSum=0, hSum=0;
  for (let i=0; i<bassEnd; i++)              bSum += freqData[i];
  for (let i=bassEnd; i<midEnd; i++)         mSum += freqData[i];
  for (let i=midEnd; i<freqData.length; i++) hSum += freqData[i];

  const bass   = bSum/(bassEnd*255);
  const mid    = mSum/((midEnd-bassEnd)*255);
  const hi     = hSum/((freqData.length-midEnd)*255);
  const energy = bass*0.5 + mid*0.3 + hi*0.2;

  const s = 0.20;
  sBass   += (bass-sBass)*s;
  sMid    += (mid-sMid)*s;
  sHi     += (hi-sHi)*s;
  sEnergy += (energy-sEnergy)*s;

  if (bass - prevBass > 0.12) burstVal = 1.0;
  prevBass = bass;
}

function drawWaveform() {
  const w=waveCanvas.width, h=waveCanvas.height;
  wCtx.clearRect(0,0,w,h);
  if (!analyser) return;
  const grad = wCtx.createLinearGradient(0,0,w,0);
  grad.addColorStop(0,'rgba(140,100,255,0.7)');
  grad.addColorStop(0.5,'rgba(200,170,255,0.9)');
  grad.addColorStop(1,'rgba(140,100,255,0.7)');
  wCtx.strokeStyle=grad; wCtx.lineWidth=1.8; wCtx.beginPath();
  const sliceW=w/waveData.length;
  for (let i=0;i<waveData.length;i++) {
    const x=i*sliceW, y=(waveData[i]/255.0)*h;
    i===0 ? wCtx.moveTo(x,y) : wCtx.lineTo(x,y);
  }
  wCtx.stroke();
}

function updateUI() {
  document.getElementById('bass').textContent  = (sBass*100).toFixed(0);
  document.getElementById('mid').textContent   = (sMid*100).toFixed(0);
  document.getElementById('hi').textContent    = (sHi*100).toFixed(0);
  document.getElementById('fps').textContent   = fps;
  document.getElementById('intensity-ring').style.setProperty('--intensity', sEnergy.toFixed(3));
}

function render(time) {
  const dt = time - lastTime;
  lastTime = time;
  if (dt>0) fps = Math.round(1000/dt);

  getAudioData();
  burstVal = Math.max(burstVal - dt/150.0, 0.0);

  drawWaveform();
  updateUI();

  gl.uniform1f(uTime,   time*0.001);
  gl.uniform1f(uBass,   sBass);
  gl.uniform1f(uMid,    sMid);
  gl.uniform1f(uHi,     sHi);
  gl.uniform1f(uEnergy, sEnergy);
  gl.uniform1f(uBurst,  burstVal);
  gl.uniform2f(uResolution, canvas.width, canvas.height);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
